diff -aubB ../dumb/dblorb.c ./dblorb.c
--- ../dumb/dblorb.c	2026-02-03 11:13:51.220737400 -0600
+++ ./dblorb.c	2026-02-01 21:59:07.975234000 -0600
@@ -20,6 +20,7 @@
  */
 
 
+#ifndef NO_BLORB
 #include "dfrotz.h"
 #include "dblorb.h"
 
@@ -30,8 +31,6 @@
 #include <unistd.h>
 #include <math.h>
 
-#ifndef NO_BLORB
-
 extern f_setup_t f_setup;
 
 FILE *blorb_fp;
diff -aubB ../dumb/dblorb.h ./dblorb.h
--- ../dumb/dblorb.h	2026-02-03 11:13:51.215735700 -0600
+++ ./dblorb.h	2026-02-02 22:12:07.207665900 -0600
@@ -19,6 +19,7 @@
 	unsigned long samples;
 	unsigned short bits;
 	double rate;
+#error floating point	
 } sampledata_t;
 
 
Only in .: delta
diff -aubB ../dumb/dfrotz.h ./dfrotz.h
--- ../dumb/dfrotz.h	2026-02-03 11:13:51.217736400 -0600
+++ ./dfrotz.h	2026-02-01 22:04:42.959558200 -0600
@@ -26,6 +26,9 @@
 
 #include <sys/param.h>
 
+#define fprintf(stream,...) printf(__VA_ARGS__)
+#define vfprintf(stream,s,m) printf(s,m)
+
 #ifndef MAX
 #define MAX(x,y) ((x)>(y)) ? (x) : (y)
 #endif
diff -aubB ../dumb/dinit.c ./dinit.c
--- ../dumb/dinit.c	2026-02-04 20:17:10.314032800 -0600
+++ ./dinit.c	2026-02-04 20:18:32.319902100 -0600
@@ -19,6 +19,7 @@
  * Or visit http://www.fsf.org/
  */
 
+#include <hp165x.h>
 #include <stdarg.h>
 
 #include "dfrotz.h"
@@ -54,7 +55,7 @@
 While running, enter \"\\help\" to list the runtime escape sequences.\n"
 
 
-static int user_text_width = 80;
+static int user_text_width = 74;
 static int user_text_height = 24;
 static int user_random_seed = -1;
 static bool plain_ascii = FALSE;
@@ -69,12 +70,26 @@
  * Some variables may be set to activate special features of Frotz.
  *
  */
-void os_process_arguments(int argc, char *argv[])
+void os_process_arguments(int _argc, char *_argv[])
 {
 	int c, num;
 	char *p = NULL;
 	char *format_orig = NULL;
 
+	int argc = 2;
+	putText("Story filename: ");
+//	static char filename[MAX_FILENAME_LENGTH];
+	patchVBL();
+	*SCREEN_MEMORY_CONTROL = WRITE_BLACK;
+	fillScreen();
+	*SCREEN_MEMORY_CONTROL = WRITE_WHITE;
+	setTextColors(WRITE_WHITE,WRITE_BLACK);
+	initKeyboard(1);
+	delayTicks(60);
+//	if (getText(filename,MAX_FILENAME_LENGTH)<0)
+//		reload();
+	char* argv[2] = {"hpfrotz", "ZORK1.Z3"};
+
 	zoptarg = NULL;
 
 	do_more_prompts = TRUE;
@@ -255,10 +270,8 @@
 	if ( p != NULL )
 		*p = '\0';	/* extension removed */
 
-
-	/* Create nice default file names */
-
 #ifndef NO_SCRIPT
+	/* Create nice default file names */
 	f_setup.script_name = malloc((strlen(f_setup.story_name) + strlen(EXT_SCRIPT) + 1) * sizeof(char));
 	memcpy(f_setup.script_name, f_setup.story_name, (strlen(f_setup.story_name) + strlen(EXT_SCRIPT)) * sizeof(char));
 	strncat(f_setup.script_name, EXT_SCRIPT, strlen(EXT_SCRIPT)+1);
@@ -327,7 +340,11 @@
  */
 void os_quit(int status)
 {
-	exit(status);
+	printf("QUIT\n");
+	setKeyWait(0);
+	while(getKey()!=KEY_STOP); 
+	reload();
+//	exit(status);
 } /* os_quit */
 
 
@@ -456,6 +473,9 @@
 #endif
 } /* os_storyfile_tell */
 
+long int time(long int* timer) {
+	return getVBLCounter()/60;
+}
 
 void os_init_setup(void)
 {
@@ -466,8 +486,8 @@
 static void usage(void)
 {
 	printf("FROTZ V%s - Dumb interface.\n", VERSION);
-	puts(INFORMATION);
-	puts(INFO2);
+	putText(INFORMATION);
+	putText(INFO2);
 	return;
 } /* usage */
 
diff -aubB ../dumb/dinput.c ./dinput.c
--- ../dumb/dinput.c	2026-02-03 11:13:51.216736000 -0600
+++ ./dinput.c	2026-02-03 22:25:49.757449300 -0600
@@ -19,8 +19,10 @@
  * Or visit http://www.fsf.org/
  */
 
+#include <hp165x.h>
 #include <string.h>
 #include <assert.h>
+#include <stdio.h>
 
 #include "dfrotz.h"
 
@@ -72,7 +74,7 @@
 	"            (blank) Any other output line.\n"
 ;
 
-static float speed = 1;
+static int speed_100 = 100;
 
 enum input_type {
 	INPUT_CHAR,
@@ -84,27 +86,7 @@
 /* get a character.  Exit with no fuss on EOF.  */
 static int xgetchar(void)
 {
-	int c = getchar();
-	if (c == EOF) {
-		if (feof(stdin)) {
-			fprintf(stderr, "\nEOT\n");
-			os_quit(EXIT_SUCCESS);
-		}
-#ifdef TOPS20
-		/* On TOPS-20 only, the very first getchar() may return EOF,
-		 * even thought feof(stdin) is false.  No idea why, but...
-		 */
-		if (!spurious_getchar) {
-			spurious_getchar = TRUE;
-			return xgetchar();
-		} else {
-			os_fatal(strerror(errno));
-		}
-#else
-		os_fatal(strerror(errno));
-#endif
-	}
-	return c;
+	return getch();
 } /* xgetchar */
 
 
@@ -113,20 +95,11 @@
  * other places where I'm not so careful).  */
 static void dumb_getline(char *s)
 {
-	int c;
-	char *p = s;
-	while (p < s + INPUT_BUFFER_SIZE - 1) {
-		if ((*p++ = xgetchar()) == '\n') {
-			*p = '\0';
-			return;
-		}
-	}
-	p[-1] = '\n';
-	p[0] = '\0';
-	while ((c = xgetchar()) != '\n')
-		;
-	printf("Line too long, truncated to %s\n", s - INPUT_BUFFER_SIZE);
-} /* dumb_getline */
+	getText(s, INPUT_BUFFER_SIZE-2);
+	int l = strlen(s);
+	s[l] = '\n';
+	s[l+1] = 0;
+} 
 
 
 /* Translate in place all the escape characters in s.  */
@@ -207,14 +180,14 @@
 bool dumb_handle_setting(const char *setting, bool show_cursor, bool startup)
 {
 	if (!strncmp(setting, "sf", 2)) {
-		speed = atof(&setting[2]);
-		printf("Speed Factor %g\n", speed);
+		speed_100 = atoi(&setting[2]);
+		printf("Speed Factor %d\n", speed_100);
 	} else if (!strncmp(setting, "mp", 2)) {
 		toggle(&do_more_prompts, setting[2]);
 		printf("More prompts %s\n", do_more_prompts ? "ON" : "OFF");
 	} else {
 		if (!strcmp(setting, "set")) {
-			printf("Speed Factor %g\n", speed);
+			printf("Speed Factor %d\n", speed_100);
 			printf("More Prompts %s\n",
 				do_more_prompts ? "ON" : "OFF");
 		}
@@ -248,19 +221,18 @@
 	for (;;) {
 		char *command;
 		if (prompt)
-			fputs(prompt, stdout);
+			putText(prompt);
 		else
 			dumb_show_prompt(show_cursor,
 				(timeout ? "tTD" : ")>}")[type]);
 
 		/* Prompt only shows up after user input if we don't flush stdout */
-		fflush(stdout);
 		dumb_getline(s);
 		if ((s[0] != '\\') || ((s[1] != '\0') && !islower(s[1]))) {
 			/* Is not a command line.  */
 			translate_special_chars(s);
 			if (timeout) {
-				int elapsed = (time(0) - start_time) * 10 * speed;
+				int elapsed = (time(0) - start_time) * 10 * speed_100 / 100;
 				if (elapsed > timeout) {
 					time_ahead = elapsed - timeout;
 					return TRUE;
@@ -285,7 +257,7 @@
 				int elapsed = atoi(&command[1]);
 				time_t now = time(0);
 				if (elapsed == 0)
-					elapsed = (now - start_time) * 10 * speed;
+					elapsed = (now - start_time) * 10 * speed_100 / 100;
 				if (elapsed >= timeout) {
 					time_ahead = elapsed - timeout;
 					s[0] = '\0';
@@ -304,7 +276,7 @@
 			}
 		} else if (!strcmp(command, "help")) {
 			if (!do_more_prompts)
-				fputs(runtime_usage, stdout);
+				putText(runtime_usage);
 			else {
 				char *current_page, *next_page;
 				current_page = next_page = runtime_usage;
@@ -318,7 +290,6 @@
 					if (!*current_page)
 						break;
 					printf("HELP: Type <return> for more, or q <return> to stop: ");
-					fflush(stdout);
 					dumb_getline(s);
 					if (!strcmp(s, "q\n"))
 						break;
@@ -627,6 +598,7 @@
 		if (tolower(fullpath[0]) != 'y')
 			return NULL;
 	}
+	printf("FNAME:{%s}\n",file_name);
 	return file_name;
 } /* os_read_file_name */
 
@@ -643,7 +615,8 @@
 
 void dumb_init_input(void)
 {
-	if ((z_header.version >= V4) && (speed != 0))
+	initKeyboard(1);
+	if ((z_header.version >= V4) && (speed_100 != 0))
 		z_header.config |= CONFIG_TIMEDINPUT;
 
 	if (z_header.version >= V5)
diff -aubB ../dumb/doutput.c ./doutput.c
--- ../dumb/doutput.c	2026-02-03 11:13:51.203726400 -0600
+++ ./doutput.c	2026-02-03 22:54:12.035265400 -0600
@@ -19,6 +19,7 @@
  * Or visit http://www.fsf.org/
  */
 
+#include <hp165x.h>
 #include "dfrotz.h"
 
 #define DEFAULT_DUMB_COLOUR 31
@@ -101,22 +102,22 @@
  * Local functions
  */
 #ifdef USE_UTF8
-static void zputchar(zchar);
-void zputchar(zchar c)
+static void zputChar(zchar);
+void zputChar(zchar c)
 {
 	if(c > 0x7ff) {
-		putchar(0xe0 | ((c >> 12) & 0xf));
-		putchar(0x80 | ((c >> 6) & 0x3f));
-		putchar(0x80 | (c & 0x3f));
+		putChar(0xe0 | ((c >> 12) & 0xf));
+		putChar(0x80 | ((c >> 6) & 0x3f));
+		putChar(0x80 | (c & 0x3f));
 	} else if(c > 0x7f) {
-		putchar(0xc0 | ((c >> 6) & 0x1f));
-		putchar(0x80 | (c & 0x3f));
+		putChar(0xc0 | ((c >> 6) & 0x1f));
+		putChar(0x80 | (c & 0x3f));
 	} else {
-		putchar(c);
+		putChar(c);
 	}
-} /* zputchar */
+} /* zputChar */
 #else
-#define zputchar(x) putchar(x)
+#define zputChar(x) putChar(x)
 #endif
 
 
@@ -145,7 +146,7 @@
 	}
 
 	if (fg != lastfg || bg != lastbg) {
-		putchar ('\017');	/* ^O cancels all text styles */
+		putChar ('\017');	/* ^O cancels all text styles */
 		lastbold = 0;
 		lastemph = 0;
 
@@ -160,28 +161,28 @@
 
 	if (cel.style & BOLDFACE_STYLE) {
 		if (!lastbold)
-			putchar('\002');
+			putChar('\002');
 		lastbold = 1;
 	} else {
 		if (lastbold)
-			putchar('\002');
+			putChar('\002');
 		lastbold = 0;
 	}
 
 	if (cel.style & EMPHASIS_STYLE) {
 		if (!lastemph)
-			putchar('\037');
+			putChar('\037');
 		lastemph = 1;
 	} else {
 		if (lastemph)
-			putchar('\037');
+			putChar('\037');
 		lastemph = 0;
 	}
 
 	if (cel.style & PICTURE_STYLE)
-		zputchar(show_pictures ? cel.c : ' ');
+		zputChar(show_pictures ? cel.c : ' ');
 	else
-		zputchar(cel.c);
+		zputChar(cel.c);
 
 	lastfg = fg;
 	lastbg = bg;
@@ -256,9 +257,9 @@
 	}
 
 	if (cel.style & PICTURE_STYLE)
-		zputchar(show_pictures ? cel.c : ' ');
+		zputChar(show_pictures ? cel.c : ' ');
 	else
-		zputchar(cel.c);
+		zputChar(cel.c);
 } /* show_cell_ansi */
 
 
@@ -347,13 +348,13 @@
 	}
 
 	if (cel.style & PICTURE_STYLE)
-		zputchar(show_pictures ? cel.c : ' ');
+		zputChar(show_pictures ? cel.c : ' ');
 	else if (strchr("[]\\`*|_#<>=-.+~&", cel.c))
 		printf("\\%c", cel.c);
 	else if (cel.c == ' ' && fix)
 		printf("&nbsp;");
 	else
-		zputchar(cel.c);
+		zputChar(cel.c);
 } /* show_cell_bbcode */
 #endif /* DISABLE_FORMATS */
 
@@ -368,30 +369,30 @@
 			switch (rv_mode) {
 			case RV_CAPS:
 				if (cel.c <= 0x7f) {
-					zputchar(toupper(cel.c));
+					zputChar(toupper(cel.c));
 					break;
 				}
 				/* fall through */
 			case RV_NONE:
-				zputchar(cel.c);
+				zputChar(cel.c);
 				break;
 			case RV_UNDERLINE:
-				putchar('_');
-				putchar('\b');
-				zputchar(cel.c);
+				putChar('_');
+				putChar('\b');
+				zputChar(cel.c);
 				break;
 			case RV_DOUBLESTRIKE:
-				zputchar(cel.c);
-				putchar('\b');
-				zputchar(cel.c);
+				zputChar(cel.c);
+				putChar('\b');
+				zputChar(cel.c);
 				break;
 			}
 		}
 	}
 	else if (cel.style & PICTURE_STYLE)
-		zputchar(show_pictures ? cel.c : ' ');
+		zputChar(show_pictures ? cel.c : ' ');
 	else	/* Only NORMAL_STYLE and FIXED_WIDTH_STYLE are left. */
-		zputchar(cel.c);
+		zputChar(cel.c);
 } /* show_cell_normal */
 
 
@@ -662,7 +663,7 @@
 	if (visual_bell)
 		printf("[%s-PITCHED BEEP]\n", (volume == 1) ? "HIGH" : "LOW");
 	else
-		putchar('\a'); /* so much for dumb.  */
+		putChar('\a'); /* so much for dumb.  */
 } /* os_beep */
 
 
@@ -795,9 +796,6 @@
 {
 #ifndef DISABLE_FORMATS
 	if (f_setup.format == FORMAT_IRC) {
-		setvbuf(stdout, 0, _IONBF, 0);
-		setvbuf(stderr, 0, _IONBF, 0);
-
 		z_header.config |= CONFIG_COLOUR | CONFIG_BOLDFACE | CONFIG_EMPHASIS;
 
 		memset (frotz_to_dumb, 256, DEFAULT_DUMB_COLOUR);
@@ -814,9 +812,6 @@
 		z_header.default_foreground = WHITE_COLOUR;
 		z_header.default_background = BLACK_COLOUR;
 	} else if (f_setup.format == FORMAT_ANSI) {
-		setvbuf(stdout, 0, _IONBF, 0);
-		setvbuf(stderr, 0, _IONBF, 0);
-
 		z_header.config |= CONFIG_COLOUR | CONFIG_BOLDFACE | CONFIG_EMPHASIS;
 
 		memset (frotz_to_dumb, 256, DEFAULT_DUMB_COLOUR);
@@ -835,9 +830,6 @@
 		z_header.default_foreground = WHITE_COLOUR;
 		z_header.default_background = BLACK_COLOUR;
 	} else if (f_setup.format == FORMAT_BBCODE) {
-		setvbuf(stdout, 0, _IONBF, 0);
-		setvbuf(stderr, 0, _IONBF, 0);
-
 		z_header.config |= CONFIG_COLOUR | CONFIG_BOLDFACE | CONFIG_EMPHASIS;
 
 		memset (frotz_to_dumb, 256, DEFAULT_DUMB_COLOUR);
@@ -1064,7 +1056,7 @@
 
 		for (p = "sample reverse text"; *p; p++)
 			show_cell(make_cell(REVERSE_STYLE, DEFAULT_DUMB_COLOUR, DEFAULT_DUMB_COLOUR, *p));
-		putchar('\n');
+		putChar('\n');
 		for (i = 0; i < screen_cells; i++)
 			screen_changes[i] = (screen_data[i].style == REVERSE_STYLE);
 		dumb_show_screen(show_cursor);
@@ -1080,7 +1072,7 @@
 			rv_names[rv_mode], rv_blank_str);
 		for (p = "sample reverse text"; *p; p++)
 			show_cell(make_cell(REVERSE_STYLE, DEFAULT_DUMB_COLOUR, DEFAULT_DUMB_COLOUR, *p));
-		putchar('\n');
+		putChar('\n');
 	} else
 		return FALSE;
 	return TRUE;
Only in .: fakefile.c
